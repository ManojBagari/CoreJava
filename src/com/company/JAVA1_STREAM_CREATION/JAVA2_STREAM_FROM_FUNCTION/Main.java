package com.company.JAVA1_STREAM_CREATION.JAVA2_STREAM_FROM_FUNCTION;

import java.util.function.IntSupplier;
import java.util.function.IntUnaryOperator;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import java.util.stream.LongStream;
import java.util.stream.Stream;

public class Main {

    public static void main(String[] args) {
    /*
        We can have a function that can generate values on demand.

        The following two static methods from Stream

        interface generates an infinite stream from a function.

        <T> Stream<T> iterate(T  seed, UnaryOperator<T> f)
        <T> Stream<T> generate(Supplier<T> s)

        iterate() method creates a sequential ordered stream.

        generate() method creates a sequential unordered stream.

        IntStream, LongStream, and DoubleStream contain iterate() and generate() methods
        that take parameters specific to their primitive types and generate values.

        For example, the following two methods are defined in the IntStream interface:

        IntStream iterate(int seed,  IntUnaryOperator f)
        IntStream generate(IntSupplier s)
    */
/*

Stream.iterate()

    The iterate() method takes two arguments: a seed and a function.

    A seed is the first element of the stream. The second element is generated by applying the function to the first element. The third element is generated by applying the function on the second element.

    Therefore the elements are: seed, f(seed), f(f(seed)), f(f(f(seed)))....

    The following code creates a stream of natural numbers:
    Stream<Long> naturalNumbers = Stream.iterate(1L, n -> n + 1);

    The limit(long maxSize) operation is an intermediate operation that produces another stream.

    The following code creates a stream of the first 10 natural numbers:
*/

        Stream<Long> tenNaturalNumbers =  Stream.iterate(1L, n -> n + 1)
                                                .limit(10);
        tenNaturalNumbers.forEach(System.out::println);

//        The following code filters the values generated from an iterate function.

        Stream.iterate(2L, n  ->  n  + 1)
                .filter(Main::isOdd)
                .limit(5)
                .forEach(System.out::println);

/*
        To discard some elements from a stream, use the skip operation.

        The skip(long n), an intermediate operation, skips the first n elements of the stream.

        The following code uses skip to skip the first 100 odd number:
*/
        Stream.iterate(2L, n  ->  n  + 1)
                .filter(Main::isOdd)
                .skip(100)
                .limit(5)
                .forEach(System.out::println);

        /*  Stream.generate()

        generate(Supplier<T> s) uses Supplier to generate an infinite sequential unordered stream.
*/

        Stream.generate(Math::random)
                .limit(5)
                .forEach(System.out::println);


//        To generate a stream in which the next element is generated based on the previous one,
//        you will need to use a Supplier that stores the last generated element.

//        The following code keeps the last value in a static variable.

        Stream.generate(Main::next)
                .limit(5)
                .forEach(System.out::println);





    }

    static int i=0;
    private static int next(){
        i++;
        return i;
    }

    public static boolean isOdd(long number) {
        if (number % 2 == 0) {
            return false;
        }
        return true;
    }


}
